{
  "version": 3,
  "sources": ["../../../../../node_modules/@casl/react/src/Can.ts", "../../../../../node_modules/@casl/react/src/factory.ts", "../../../../../node_modules/@casl/react/src/hooks/useAbility.ts"],
  "sourcesContent": ["import { PureComponent, ReactNode } from 'react';\nimport {\n  Unsubscribe,\n  AbilityTuple,\n  SubjectType,\n  AnyAbility,\n  Generics,\n  Abilities,\n  IfString,\n} from '@casl/ability';\n\nconst noop = () => {};\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\ninterface ExtraProps {\n  not?: boolean\n  passThrough?: boolean\n}\n\ninterface CanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\ninterface BoundCanExtraProps<T extends AnyAbility> extends ExtraProps {\n  ability?: T\n  children: ReactNode | ((isAllowed: boolean, ability: T) => ReactNode)\n}\n\nexport type CanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & CanExtraProps<T>;\nexport type BoundCanProps<T extends AnyAbility> =\n  AbilityCanProps<Generics<T>['abilities']> & BoundCanExtraProps<T>;\n\nexport class Can<T extends AnyAbility> extends PureComponent<CanProps<T>, { t: boolean }> {\n  private _isAllowed = false;\n  private _ability: T | null = null;\n  private _unsubscribeFromAbility: Unsubscribe = noop;\n  state = { t: true }\n\n  componentWillUnmount() {\n    this._unsubscribeFromAbility();\n  }\n\n  private _connectToAbility(ability?: T) {\n    if (ability === this._ability) {\n      return;\n    }\n\n    this._unsubscribeFromAbility();\n    this._ability = null;\n\n    if (ability) {\n      this._ability = ability;\n      this._unsubscribeFromAbility = ability.on('updated', () => this.setState({ t: !this.state.t }));\n    }\n  }\n\n  get allowed() {\n    return this._isAllowed;\n  }\n\n  private _canRender(): boolean {\n    const props: any = this.props;\n    const subject = props.of || props.a || props.an || props.this || props.on;\n    const can = props.not ? 'cannot' : 'can';\n\n    return props.ability[can](props.I || props.do, subject, props.field);\n  }\n\n  render() {\n    this._connectToAbility(this.props.ability);\n    this._isAllowed = this._canRender();\n    return this.props.passThrough || this._isAllowed ? this._renderChildren() : null;\n  }\n\n  private _renderChildren() {\n    const { children, ability } = this.props;\n    const elements = typeof children === 'function'\n      ? children(this._isAllowed, ability as any)\n      : children;\n\n    return elements as ReactNode;\n  }\n}\n", "import { AnyAbility } from '@casl/ability';\nimport { Consumer, FunctionComponent, createElement } from 'react';\nimport { BoundCanProps, Can } from './Can';\n\nexport function createContextualCan<T extends AnyAbility>(\n  Getter: Consumer<T>\n): FunctionComponent<BoundCanProps<T>> {\n  return (props: BoundCanProps<T>) => createElement(Getter, {\n    children: (ability: T) => \n      createElement(Can, { ...props, ability: props.ability || ability } as any),\n  });\n}\n", "import React from 'react';\nimport { AnyAbility } from '@casl/ability';\n\nexport function useAbility<T extends AnyAbility>(context: React.Context<T>): T {\n  const ability = React.useContext<T>(context);\n  const [rules, setRules] = React.useState<T['rules']>();\n\n  React.useEffect(() => ability.on('updated', (event) => {\n    if (event.rules !== rules) {\n      setRules(event.rules);\n    }\n  }), []);\n\n  return ability;\n}\n"],
  "mappings": ";;;;;;;;;AAWA,IAAMA,IAAOA,MAAAA;AAAAA;AAgCN,IAAMC,IAAN,cAAwCC,aAAAA,cAAAA;EAA2CC,eAAAC,IAAAA;AAAAC,UAAAA,GAAAD,EAAAA;AAAAE,SAChFC,IAAa;AAAKD,SAClBE,IAAqB;AAAIF,SACzBG,IAAuCT;AAAIM,SACnDI,QAAQ,EAAEC,GAAG,KAAA;EAAM;EAEnBC,uBAAAA;AACEN,SAAKG,EAAAA;EACP;EAEQI,EAAkBC,IAAAA;AACxB,QAAIA,OAAYR,KAAKE,EACnB;AAGFF,SAAKG,EAAAA;AACLH,SAAKE,IAAW;AAEhB,QAAIM,IAAS;AACXR,WAAKE,IAAWM;AAChBR,WAAKG,IAA0BK,GAAQC,GAAG,WAAW,MAAMT,KAAKU,SAAS,EAAEL,GAAAA,CAAIL,KAAKI,MAAMC,EAAAA,CAAAA,CAAAA;IAC5F;EACF;EAEA,IAAA,UAAIM;AACF,WAAOX,KAAKC;EACd;EAEQW,IAAAA;AACN,UAAMC,KAAab,KAAKa;AACxB,UAAMC,KAAUD,GAAME,MAAMF,GAAMG,KAAKH,GAAMI,MAAMJ,GAAMb,QAAQa,GAAMJ;AACvE,UAAMS,KAAML,GAAMM,MAAM,WAAW;AAEnC,WAAON,GAAML,QAAQU,EAAAA,EAAKL,GAAMO,KAAKP,GAAMQ,IAAIP,IAASD,GAAMS,KAAAA;EAChE;EAEAC,SAAAA;AACEvB,SAAKO,EAAkBP,KAAKa,MAAML,OAAAA;AAClCR,SAAKC,IAAaD,KAAKY,EAAAA;AACvB,WAAOZ,KAAKa,MAAMW,eAAexB,KAAKC,IAAaD,KAAKyB,EAAAA,IAAoB;EAC9E;EAEQA,IAAAA;AACN,UAAA,EAAMC,UAAEA,IAAQlB,SAAEA,GAAAA,IAAYR,KAAKa;AACnC,UAAMc,KAAAA,OAAkBD,OAAa,aACjCA,GAAS1B,KAAKC,GAAYO,EAAAA,IAC1BkB;AAEJ,WAAOC;EACT;AAAA;ACxFK,SAASC,EACdC,IAAAA;AAEA,SAAQhB,CAAAA,WAA4BiB,aAAAA,eAAcD,IAAQ,EACxDH,UAAWlB,CAAAA,WACTsB,aAAAA,eAAcnC,GAAGoC,OAAAC,OAAA,CAAA,GAAOnB,IAAK,EAAEL,SAASK,GAAML,WAAWA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAE/D;ACRO,SAASyB,WAAiCC,IAAAA;AAC/C,QAAM1B,KAAU2B,aAAAA,QAAMC,WAAcF,EAAAA;AACpC,QAAA,CAAOG,IAAOC,EAAAA,IAAYH,aAAAA,QAAMI,SAAAA;AAEhCJ,eAAAA,QAAMK,UAAU,MAAMhC,GAAQC,GAAG,WAAYgC,CAAAA,OAAAA;AAC3C,QAAIA,GAAMJ,UAAUA,GAClBC,CAAAA,GAASG,GAAMJ,KAAAA;EACjB,CAAA,GACE,CAAA,CAAA;AAEJ,SAAO7B;AACT;",
  "names": ["noop", "Can", "PureComponent", "constructor", "args", "super", "this", "_isAllowed", "_ability", "_unsubscribeFromAbility", "state", "t", "componentWillUnmount", "_connectToAbility", "ability", "on", "setState", "allowed", "_canRender", "props", "subject", "of", "a", "an", "can", "not", "I", "do", "field", "render", "passThrough", "_renderChildren", "children", "elements", "createContextualCan", "Getter", "createElement", "Object", "assign", "useAbility", "context", "React", "useContext", "rules", "setRules", "useState", "useEffect", "event"]
}
